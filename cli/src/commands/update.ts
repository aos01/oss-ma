// cli/src/commands/update.ts

import { Command } from "commander";
import path from "node:path";
import crypto from "node:crypto";
import fs from "fs-extra";
import pc from "picocolors";
import { input, confirm } from "@inquirer/prompts";
import { readTemplateLock } from "../engine/readLock.js";
import { loadTemplate } from "../engine/loadTemplate.js";
import { writeTemplateLock } from "../engine/lock.js";
import { copyAndRenderDir } from "../engine/copy.js";

async function hashFile(filePath: string): Promise<string> {
  const content = await fs.readFile(filePath);
  return crypto.createHash("sha256").update(content).digest("hex");
}

async function collectTemplateFiles(filesDir: string): Promise<Set<string>> {
  const files = new Set<string>();
  const entries = await fs.readdir(filesDir, { withFileTypes: true });

  for (const entry of entries) {
    const full = path.join(filesDir, entry.name);
    if (entry.isDirectory()) {
      const subFiles = await collectTemplateFiles(full);
      for (const sub of subFiles) {
        files.add(path.join(entry.name, sub).replace(/\\/g, "/"));
      }
    } else if (entry.isFile()) {
      files.add(entry.name);
    }
  }

  return files;
}

type FileStatus = {
  path: string;
  status: "added" | "modified" | "deleted" | "unchanged";
  userModified: boolean;
};

export const updateCommand = new Command("update")
  .option("--path <path>", "Project path", ".")
  .option("--yes", "Auto-accept all updates without prompts")
  .option("--dry-run", "Show what would be updated without making changes")
  .description("Update project to latest template version")
  .action(async (opts: { path: string; yes?: boolean; dryRun?: boolean }) => {
    try {
      const projectPath = path.resolve(opts.path);

      // 1) Read current lock
      const lock = await readTemplateLock(projectPath);
      if (!lock) {
        console.log(pc.red("❌ Error:"), "No template.lock found. Project not generated by tpl.");
        process.exit(1);
      }

      console.log(pc.cyan("Current version:"), `${lock.template}@${lock.version}`);

      // 2) Load current and latest template
      const currentTemplate = await loadTemplate(lock.template);
      const latestVersion = currentTemplate.spec.version;

      if (lock.version === latestVersion) {
        console.log(pc.green("✅"), "Already at latest version");
        process.exit(0);
      }

      console.log(pc.cyan("Latest version:"), `${lock.template}@${latestVersion}`);

      if (!opts.yes && !opts.dryRun) {
        const proceed = await confirm({
          message: `Update from ${lock.version} to ${latestVersion}?`,
          default: true,
        });
        if (!proceed) {
          console.log("Update cancelled");
          process.exit(0);
        }
      }

      // 3) Analyze changes
      const latestFiles = await collectTemplateFiles(currentTemplate.filesDir);
      const changes: FileStatus[] = [];

      for (const relPath of latestFiles) {
        const projectFilePath = path.join(projectPath, relPath);
        const exists = await fs.pathExists(projectFilePath);

        if (!exists) {
          changes.push({ path: relPath, status: "added", userModified: false });
          continue;
        }

        const currentHash = await hashFile(projectFilePath);
        const originalHash = lock.filesIntegrity?.[relPath];

        const userModified = originalHash && currentHash !== originalHash;

        // Compare with new template version
        const templateFilePath = path.join(currentTemplate.filesDir, relPath);
        const templateHash = await hashFile(templateFilePath);

        if (currentHash === templateHash) {
          changes.push({ path: relPath, status: "unchanged", userModified: false });
        } else {
          changes.push({
            path: relPath,
            status: originalHash ? "modified" : "added",
            userModified: !!userModified,
          });
        }
      }

      // Check for deleted files
      if (lock.filesIntegrity) {
        for (const relPath of Object.keys(lock.filesIntegrity)) {
          if (!latestFiles.has(relPath)) {
            changes.push({ path: relPath, status: "deleted", userModified: false });
          }
        }
      }

      // 4) Report changes
      const toUpdate = changes.filter((c) => c.status !== "unchanged");

      if (toUpdate.length === 0) {
        console.log(pc.green("✅"), "No changes to apply");
        process.exit(0);
      }

      console.log("");
      console.log(pc.bold("Changes to apply:"));
      for (const change of toUpdate) {
        const icon =
          change.status === "added"
            ? pc.green("+")
            : change.status === "deleted"
            ? pc.red("-")
            : pc.yellow("~");
        const warning = change.userModified ? pc.red(" (user modified)") : "";
        console.log(`${icon} ${change.path}${warning}`);
      }

      if (opts.dryRun) {
        console.log("");
        console.log(pc.cyan("Dry run mode — no changes made"));
        process.exit(0);
      }

      // 5) Apply updates
      console.log("");
      let updated = 0;
      let skipped = 0;

      for (const change of toUpdate) {
        const projectFilePath = path.join(projectPath, change.path);
        const templateFilePath = path.join(currentTemplate.filesDir, change.path);

        if (change.status === "deleted") {
          console.log(pc.gray(`Skipping deletion: ${change.path}`));
          skipped++;
          continue;
        }

        if (change.userModified && !opts.yes) {
          const overwrite = await confirm({
            message: `Overwrite user-modified file: ${change.path}?`,
            default: false,
          });

          if (!overwrite) {
            console.log(pc.gray(`Skipped: ${change.path}`));
            skipped++;
            continue;
          }
        }

        await fs.copy(templateFilePath, projectFilePath, { overwrite: true });
        console.log(pc.green(`Updated: ${change.path}`));
        updated++;
      }

      // 6) Update lock
      await writeTemplateLock({
        destDir: projectPath,
        template: lock.template,
        version: latestVersion,
        options: lock.options ?? {},
        packs: lock.packs,
        generatedAt: new Date().toISOString(),
      });

      console.log("");
      console.log(pc.green("✅ Update complete"));
      console.log(`Updated: ${updated} files`);
      if (skipped > 0) console.log(`Skipped: ${skipped} files`);

      process.exit(0);
    } catch (err: any) {
      console.error(pc.red("❌ Error:"), err?.message ?? String(err));
      process.exit(2);
    }
  });